---
layout: post
title:  "Advent of Code 2020"
---

This is my notes about solving Advent of Code 2020 in Rust. 


# Day 1

- There was outage for the first 10 minutes so there were no leaderboard scores
- I solved this using 3 nested loops:

```rust
for i in 0..x.len() {
    for j in 0..i {
        for k in 0..j {
            if x[i] + x[j] + x[k] == 2020 {
                return x[i] * x[j] * x[k];
            }
        }
    }
}
```

- Afterwards learned about `combinations` function from [`itertools` crate](https://docs.rs/itertools/0.9.0/itertools/trait.Itertools.html#method.combinations):

```rust
let v = x
    .iter()
    .cloned()
    .combinations(3)
    .filter(|it| it.iter().sum::<i64>() == 2020)
    .next()
    .unwrap();
return v[0] * v[1] * v[2]
```

- Using `tuple_combinations` from the same package looks even cleaner:

```rust
let res = x
    .iter()
    .cloned()
    .tuple_combinations()
    .find_map(|(a, b, c)| {
        if a + b + c == 2020 {
            Some(a * b * c)
        } else {
            None
        }
    })
    .unwrap();
return res
```


# Day 2


- Solved in 5/9 minutes and got around 800th place overall

<img src="img/aoc-2020/day02.png" style="width: 75%;"/>


- Wasted some time figuring out how to index `String`-s in Rust. The syntax is pretty ugly:

```rust
let ch = parts[1].chars().nth(0).unwrap();
```

- Lost another minute or so with incorrect answers as missed 1-indexing of arrays
- Initially did some parsing using my `split_string` and `parse_i64` functions:

```rust
let parts = split_string(line, " ");
let nums = split_string(&parts[0], "-");
let a = parse_i64(&nums[0]);
let b = parse_i64(&nums[1]);
let ch = parts[1].chars().nth(0).unwrap();
let pass = parts[2];
```

- Afterwards found some pretty slick [`serde_scan` crate](https://docs.rs/serde_scan/0.4.0/serde_scan/):

```rust
let (a, b, ch, pass): (usize, usize, char, String) =
    serde_scan::scan!("{}-{} {}: {}" <- line).unwrap();
```


## Day 3

- Solved in `6:44/10:11` minutes and got at `#1240/#953` in global leaderboard

<img src="img/aoc-2020/day03.png" style="width: 75%;"/>

- Screwed up several times while trying to skim the statement too fast:
  - Missed that starting point is (1, 3) and not (0, 0) - this probably doesn't matter since the start is not at tree
  - Didn't realize that the map is cyclical
  - Missed that we need to multiply all numbers instead of sum
- Regarding Rust itself - I don't like the access pattern for strings, so maybe I should have a helper to quickly convert `String` to `Vec<Char>`:

```rust
pub fn to_vv_char(lines: &Vec<String>) -> Vec<Vec<char>> {
    lines.iter().map(|x| x.chars().collect()).collect()
}
```


## Day 4

- Solved in `11:19/28:05` minutes and got at `#1800/1091` in global leaderboard

<img src="img/aoc-2020/day04.png" style="width: 75%;"/>

- Didn't really like the problem since it was pretty straightforward but required a lot of careful coding
- Maybe that's an opportunity to learn how to do that more efficiently in Rust (e.g. use regexps)
- For first part missed that `cid` is optional
- Also wasted some time with incorrect parsing - didn't take into account last block
- Surprisingly second part worked out of the box the first time I finished it
- Will check if I can simplify some of the code
- Found that `Vec` has method `contains` and splitting the string is probably faster than changing it to a vector, so `ecl` check could be written as following:

```rust
fn check_ecl(s: &String) -> bool {
    let opts = split_string(&"amb blu brn gry grn hzl oth".to_string(), " ");
    opts.contains(s)
}
```

- iterators have methd `.all` that could be used for simplification:

```rust
fn is_all_digits(s: &String) -> bool {
    s.chars().all(|c| c.is_numeric())
}
```

## Day 5

- Solved in `7:07/8:54` minutes and got at `#593/379` place. The best result so far!
- Was pretty straightforward problem - I feel that I didn't really screwed up anywhere
- Initially I implemented the binary search as described, but later turned out you can just convert the input string to binary treating "BR" -> 1 and "FL" -> 0:

```rust
fn get_seat_id_bin(s: &String) -> i64 {
    let x: String = s
        .chars()
        .map(|c| match c {
            'B' | 'R' => '1',
            _ => '0',
        })
        .collect();
    isize::from_str_radix(&x, 2).unwrap() as i64
}
```
 - Or using `.replace` instead:

```rust
fn get_seat_id_bin(s: &String) -> i64 {
    let x = s.replace("B", "1").replace("R", "1").replace("L", "0").replace("F", "0");
    isize::from_str_radix(&x, 2).unwrap() as i64
}


# Links

 - Other Rust Solutions:
    - <https://github.com/nulladdict/aoc-2020>
    - <https://github.com/floatdrop/aoc>
    - <https://github.com/smmalis37/aoc2020/>
    - <https://github.com/chinatsu/aoc2020>
